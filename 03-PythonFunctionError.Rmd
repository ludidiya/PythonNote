# 函数与异常处理{#PythonFunctionError}

## 函数定义和调用

通俗讲里面就是某一个'功能'的代码实现， 使用函数的目的对代码进行复用，降低代码冗余。函数就是实现某个功能的代码块，提高代码的复用性

**函数调用顺序**：先定义，再调用

**函数的说明文档**：可以通过`help(函数名)`来查看

```python
def sum_num(num1, num2):
    
    '''函数的功能
        计算数字和的函数
        :param num1: 第一个数字
        :param num2: 第二个数字
        :return: 返回值
    '''
    result = num1 + num2
    return result

help(sum_num)
```

## 函数的参数

### 位置参数/必选参数

位置参数也叫做必选参数。使用位置参数方式传参必须按照函数参数的顺序去传参。

```python
def func(name,age):
    print(name,age)

func('zs',18)
# zs 18
func(18,'zs')
# 18 zs
```

从上面两条参数传入的不同写法看出，位置参数的缺点在于无法控制用户输入参数是否与函数定义一一对应。

### 关键字参数

解决上述提到的可能传入参数与定义不太对应的情况，可以使用关键字参数：

```python
def func(name = 'zc', age = 2):
    print(name,age)
```

### 默认参数

定义一个计算`x`的`n`次幂的函数：`x^n`，用户不指定n时默认n=2。

```python
def power(x, n=2):
    s = 1
    while n > 0:
        n = n - 1
        s = s*x
    return s

power(5)
# 25

power(5, 3)
# 125
```

默认参数可以简化函数的调用，有几点需要注意的：

1）必选参数在前，默认参数在后；

2）当函数有多个参数时，把变化大的参数放前面，变化小的参数放后面。变化小的参数就可以作为默认参数。

### 默认参数为空，有坑！！！！{#DefaultParameterBug}

先定义一个函数，传入一个list，添加一个`END`再返回：

```python
def add_end(L=[]):
    L.append('END')
    return L
    
add_end([])
# ['END']
add_end([])
# ['END']
```

当我们不给定输入参数，运行多少遍该函数，就会不停地添加`END`到列表中：

```python
add_end()
# ['END']
add_end()
# ['END','END']
```

**解释：**python函数在定义的时候，默认参数L的值就被计算出来了，即`[]`，因为默认参数L也是一个变量，它指向对象`[]`，每次调用该函数，如果改变了`L`的内容，则下次调用时，默认参数的内容就变了，不再是函数定义时的`[]`。

**定义默认参数要牢记一点：默认参数必须指向[不变对象](#VariableAndInvariable)！！

修改上面的例子，我们可以用`None`这个不变对象来实现：

```python
def add_end(L=None):
    if L is None:
        L = []
    L.append('END')
    return L
```

现在，无论调用多少次，都不会有问题：

```python
add_end()
# ['END']
add_end()
# ['END']
```

### 可变参数

可变参数就是**传入的参数个数是可变的**，0、1、2或任意个。

定义一个计算一组数字平方和的函数，如给定一组数字`a,b,c,d...`，计算`a^2+b^2+c^2+...`

我们可以把传入的数字写成列表或元组的形式传入函数，再遍历以计算出结果，但是这样有点麻烦。利用可变参数，调用函数可以简化：

```python
def calc(*numbers):
    sum = 0
    for n in numbers:
        sum = sum + n*n
    return sum

calc(1,2,3)
# 14

calc()
# 0

# 还能这样传：python允许再list或tuple前面加一个*，把list或tuple的元素变成可变参数传进去
nums = [1,2,3]
calc(*nums)
```

### 命名关键字参数

对于关键字参数，函数的调用者可以传入任意不受限制的关键字参数。至于到底传入了什么，就需要在函数内部通过`**kw`检查。

```python
def person(name, age, **kw):
    if 'city' in kw:
        print("有city参数")
    if 'job' in kw:
        print("有job参数")
    print('name:',name,'age:',age,'other:',kw)
```

但是调用者仍然可以传入不受限制的关键字参数：

```python
person('Jack',24,city='Beijing',addr='Chaoyang',zipcode=12344)

# 有city参数
# name: Jack age: 24 other: {'city': 'Beijing', 'addr': 'Chaoyang', 'zipcode': 12344}
```

如果要限制关键字参数的名字，就可以用**命名关键字参数**，例如，只接受`city`和`job`作为关键字参数。关键字参数和`**kw`不同，命名关键字参数需要一个特殊的分隔符`*`，`*`后面的参数被视为命名关键字参数。

```python
def person(name,age,*,city,job):
    print(name,age,city,job)

person('Jack',24,city='Beijing',job='Engineer')
# Jack 24 Beijing Engineer
```
命名关键字参数在传参的时候一定要写成`参数名=?`的格式；

如果中间的`*`去掉了变成`def person(name,age,city,job)`，则四个参数都是**位置参数**。

如果函数定义中已经有了一个可变参数，后面跟着的命名关键字参数就不再需要一个特殊的分隔符`*`了：

```python
def person(*args,city,job):
    print(*args,city,job)

person('Jack',24,city='Beijing',job='Engineer')
# Jack 24 Beijing Engineer
```

### 参数组合

python中定义函数，**必选参数、默认参数、可变参数、关键字参数和命名关键字参数**这5中参数可以组合使用。但是注意：

**参数定义的顺序：**位置/必选参数 > 默认参数 > 可变参数 > 命名关键字参数和关键字参数

如定义两个函数，每个函数均包含上述不同的参数类型：

```python
def f1(a,b,c=0,*args,**kw):
    print('a =',a,'b =',b,'c =',c,'args =',args,'kw =',kw)
    
def f2(a,b,c=0,*,d,**kw):
    print('a =',a,'b =',b,'c =',c,'d =',d,'kw =',kw)
```

观察调用后的输出：

```python
f1(1,2,3,4,5,6,dog=45,cat=45)
# a = 1 b = 2 c = 3 args = (4, 5, 6) kw = {'dog': 45, 'cat': 45}

f2(1,2,3,d=4,bird=33,width=23)
# a = 1 b = 2 c = 3 d = 4 kw = {'bird': 33, 'width': 23}
```

## 函数返回值

### 带有返回值的函数

```python
def cal(a,b):
    c = a + b
    return c

# 调用函数，并保存返回值
result = cal(100,98)
print(result)
# 198
```

### 多个返回值

**(1) 多个return**

返回多个值，并不是设置多条独立的return语句，函数中第一个return后面的代码不会被执行。因为return除了能够将数据返回之外，还有一个隐藏功能就是结束函数。

**总结：**
1）一个函数中可以有多个return，可以在不同的条件下执行不同的代码，并执行不同的return以返回不同情况下的结果；

2）同一层循环/条件下的多个return不会报错，但是只有第一个return才会被执行。

```python
def cal_nums(num):
    print("-----1-----")
    if num == 100:
        print("-----2-----")
        return num+1
    else:
        print("-----3-----")
        return num+2
    print("-----4-----")
```

**(2) 一个函数返回多个数据的方式**

返回多个数据，return后面可以是元组、列表、字典等，只要是能够存储多个数据的类型，就可以一次性返回多个数据。

```python
def calculate(a,b):
        shang = a/b
        yushu = a%b
        return shang, yushu # 默认是元组
        
result = calculate(5,2)
print(result) 
# (2,1)
```

## 递归函数

在函数内部，可以调用其他函数。如果一个函数在内部调用自身本身，这个函数就是**递归函数**。

比如计算`n!`，`n! = n(n-1)!`，只有`n=1`时需要特殊处理。

于是`fact(n)`用递归的方式写出来就是：

```python
def fact(n):
        if n == 1
                return 1
        return n * fact(n-1)
```

以上就是一个递归函数，测试一下：

```python
fact(1)
# 1

fact(3)
# 6
```

### 栈溢出

递归函数的有点事定义简单，逻辑清晰。理论上，所有的递归函数都可以写成循环的方式，但循环的逻辑不如递归清晰。

使用递归函数需要**注意**防止栈溢出。在计算机中，函数调用是通过栈（stack）这种数据结构实现的，每当进入一个函数调用，栈就会加一层栈帧，每当函数返回，栈就会减一层栈帧。由于栈的大小不是无限的，所以，递归调用的次数过多，就会栈溢出。可以试试fact(10000):

```python
fact(10000)

# RecursionError: maximum recursion depth exceeded in comparison
```

### 尾递归

解决递归调用栈溢出的方法是通过**尾递归**优化，事实上尾递归和循环的效果是一样的，所以，把循环看成是一种特殊的尾递归函数也是可以的。

**尾递归**是指，在函数返回的时候，调用自身，并且，`return`语句不能包含表达式。这样，编译器或者解释器就可以把尾递归做优化，使递归本身无论调用多少次，都只占用一个栈，不会出现栈溢出的情况。

上面的`fact(n)`函数由于`return n*fact(n-1)`引入了乘法表达式，所以就不是尾递归了。要改成尾递归的方式，需要多一点代码，主要是把每一步的乘积传入到递归函数中：

```python
def fact(n):
        return fact_iter(n,1)
        
def fact_iter(num, product):
        if num == 1:
                return product
        return fact_iter(num-1, num*product)
```

可以看到，`fact_iter(num-1, num*product)`仅返回递归函数本身，`num-1`和`num*product`在函数调用前就会被计算，不会影响函数调用。

`fact(5)`对用的`fact_iter()`函数调用如下：

```
===> fact_iter(5,1)
===> fact_iter(4,5)
===> fact_iter(3,20)
===> fact_iter(2,60)
===> fact_iter(1,120)
===> 120
```

尾递归调用时，如果做了优化，栈不会增长。因此，无论多少次调用不会造成栈溢出。

遗憾的是，大多数编程语言没有针对尾递归做优化。Python解释器也没有做优化。所以，即使把上面的`fact(n)`函数改成尾递归方式，也会造成栈溢出。

**小结**
* 使用递归函数的有点事逻辑简单清晰，缺点是过深的调用会造成栈溢出；

* 针对尾递归优化的语言可以通过尾递归防止栈溢出。尾递归事实上和循环是等价的，没有循环语句的变成语言只能通过尾递归实现循环；

* Python标准的解释器没有针对尾递归做优化，任何递归函数都存在栈溢出的问题。

## 局部变量与全局变量

### 局部变量

* **局部变量**，就是在函数内部定义的变量。

* **作用范围**是这个函数内部，即只能在这个函数中使用，在函数外部是不能使用的。因为起作用范围只是在自己的函数内部，所以不同的函数可以定义相同名字的局部变量。

* **局部变量的作用**，为了临时保存数据需要在函数中定义变量来进行存储。

* 当函数调用时，局部变量被创建，当函数调用完成后这个变量就不能使用了。

### 全局变量

如果一个变量，即能在一个函数中使用，也能在其他函数中使用，这样的变量就是**全局变量**。

```python
# 定义全局变量
money = 1200

def test1():
        print(money) # 虽然没有定义变量money但是可以使用全局变量中的money
        
def test2():
        print(money) # 全局变量可以在不同函数中被调用
        
# 调用函数
test1()
test2()
```

### 全局变量和局部变量冲突问题

**代码：**

```python
# 定义全局变量
x = 100

def test1():
        # 定义局部变量，与全局变量名字相同
        x = 300
        print("---test1---%d"%x)
        # 修改
        x = 200
        print("修改后的%d"%x)

def test2():
        print("x = %d"%x)
        
test1()
test2()

# 结果
---test1---300
修改后的200
x = 100
```

**总结：**当函数内部出现局部变量和全局变量相同名字时，函数内部中的`变量名 = 数据`此时理解为定义了一个局部变量，而不是修改全局变量的值。

### 修改全局变量

函数中进行使用**全局变量**时是否进行修改呢？

可以使用`global`来声明变量为全局变量。

```python
# 定义全局变量
x = 100

def test1():
        # 定义全局变量，使用global函数声明变量x为全局变量
        global x
        print("修改之前：%d"%x)
        
        # 修改
        x = 200
        print("修改之后：%d"%x)

def test2():
        print("x = %d"%x)
        
# 调用函数
test1()
test2()

# 结果
修改之前：100
修改之后：200
x = 200
```

## 捕获异常

